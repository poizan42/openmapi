<?xml version="1.0"?>
<!--
//
// openmapi.org - NMapi C# Mapi API - props.xsl
//
// Copyright 2009 Topalis AG
//
// Author: Johannes Roith <johannes@jroith.de>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
//-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="text" omit-xml-declaration="yes" />

<xsl:include href="../common.xsl" />

<xsl:template match="/propertyclasses">
//
// DO NOT EDIT!
// This file was autogenerated.
//

using System;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;

using NMapi.Interop;
using CompactTeaSharp;
using CompactTeaSharp.Server;

using NMapi;
using NMapi.Flags;
using NMapi.Events;
using NMapi.Properties;
using NMapi.Table;
using NMapi.Rules;

namespace NMapi.Properties {

	<xsl:apply-templates select="class" />




	//
	// TODO: move this to it's own xsl file.
	//

	public partial class PropertyValue
	{
	
		private static PropertyValue DecodeRest (int ptag, XdrDecodingStream xdr)
		{
			switch (PropertyTypeHelper.PROP_TYPE (ptag)) {
				<xsl:for-each select="class">
					<xsl:choose>
						<xsl:when test="@type = 'DEFAULT'">default: return new <xsl:value-of select="@id" /> (xdr);
						</xsl:when>
						<xsl:otherwise>case PropertyType.<xsl:value-of select="@type" />: return new <xsl:value-of select="@id" /> (xdr);
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			}
		}
		
		/// &lt;summary&gt;
		///  DO NOT USE! This method does not provide type-safe access to properties.
		/// &lt;/summary&gt;
		public static PropertyValue Make (int propTag, object data)
		{
			PropertyValue val = null;
			PropertyType ptype = PropertyTypeHelper.PROP_TYPE (propTag);
			switch (ptype) {
				<xsl:for-each select="class">
					<xsl:variable name="nativeType"><xsl:call-template name="get-value-native-type"><xsl:with-param name="type" select="@type" /></xsl:call-template></xsl:variable>
					
					<xsl:choose>
						<xsl:when test="@type = 'DEFAULT'">default: val = new <xsl:value-of select="@id" /> ((int) data); break;
						</xsl:when>
						<xsl:otherwise>case PropertyType.<xsl:value-of select="@type" />: val = new <xsl:value-of select="@id" /> (
							<xsl:if test="$nativeType != ''">(<xsl:value-of select="$nativeType" />) data</xsl:if>
						); break;
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			}
			
			val.ulPropTag = propTag;
			return val;
		}
		
		
		

		<xsl:for-each select="class">
			/// &lt;summary&gt;
			///  Creates a strongly typed property value from a (strongly typed) property tag.
			/// &lt;/summary&gt;
			public static <xsl:value-of select="@id" /> CreateFromTag (<xsl:value-of select="@id" />Tag tag)
			{
				var prop = new <xsl:value-of select="@id" /> ();
				prop.PropTag = tag.Tag;
				return prop;
			}
		</xsl:for-each>
		
		<!-- TODO this currently only works if there is exactly one property that allows data to be casted to the type ... //-->
		<xsl:for-each select="class">
			<xsl:if test="autocast/text() != ''">
				/// &lt;summary&gt;
				///  Valid for <xsl:value-of select="@id" />
				/// &lt;/summary&gt;
				public static explicit operator <xsl:value-of select="autocast/text()" /> (PropertyValue p)
				{
					if (p is <xsl:value-of select="@id" />)
		    			return (<xsl:value-of select="autocast/text()" />) p.GetValueObj ();
					throw new InvalidCastException ("Only properties with type " + 
					"'<xsl:value-of select="@id" />' can be casted to <xsl:value-of select="autocast/text()" />.");
				}
			</xsl:if>
		</xsl:for-each>	
	}
	
}

</xsl:template>

<xsl:template match="class">

	public partial class <xsl:value-of select="@id" />
	{
		/// &lt;summary&gt;
		///  Implements MAPI-compatible property object comparison.
		/// &lt;/summary&gt;
		public override int CompareTo (object obj)
		{
			if (!(obj is <xsl:value-of select="@id" />))
				throw new ArgumentException ("Not a <xsl:value-of select="@id" /> property.");

			<xsl:choose>
				<xsl:when test="compare/@type = 'default'">
					return Value.CompareTo (((<xsl:value-of select="@id" />) obj).Value);
				</xsl:when>
				<xsl:when test="compare/@type = 'array'">
					return CompareArraysHelper (Value, ((<xsl:value-of select="@id" />) obj).Value);
				</xsl:when>
				<xsl:when test="compare/@type = 'fixed'">
					return <xsl:value-of select="compare/text()" />;
				</xsl:when>
				<xsl:when test="compare/@type = 'code'">
					<xsl:value-of select="compare/text()" />
				</xsl:when>
			</xsl:choose>
		}
			
		protected internal override PropertyType GetRequiredPropertyType ()
		{
			return 
			<xsl:choose>
				<xsl:when test="@type = 'DEFAULT'">PropertyType.Unspecified</xsl:when>
				<xsl:otherwise>PropertyType.<xsl:value-of select="@type" /></xsl:otherwise>
			</xsl:choose>
			;
		}
		
		public override object GetValueObj ()
		{
			return <xsl:value-of select="getobj/text()" />;
		}
	}
	
</xsl:template>
</xsl:stylesheet>
